@inherits AppComponent

<div class="table">
    <InputSearch @bind-value="searchText" isEnabled="fixedSearchText is null" />
    <div class="table-section table-section-header">
        <div>
            <div>Key</div>
            @if (isReadonly)
            {
                <div>Value</div>
            }
            else
            {
                <div>Original Value</div>
                <div style="margin-left: 1em; ">New Value</div>
                <div></div>
            }
        </div>
    </div>
    <div class="table-section table-section-content">
        @foreach (var entry in GetEntries())
        {
            var _entry = entry;
            <div class="@(_entry.isDirty ? "dirty" : "")">
                <div>@_entry.key</div>
                <div>@_entry.originalValue</div>
                @if (!isReadonly)
                {
                    <div>
                        @if (_entry.editValue is not null)
                        {
                            <Input @bind-value="_entry.editValue" />
                        }
                        else
                        {
                            @if (_entry.isDirty)
                            {
                                <div style="padding: 0 .75em; ">@_entry.newValue</div>
                            }
                        }
                    </div>
                    <div style="text-align: right; ">
                        @if (_entry.editValue is not null)
                        {
                            <Button onClick="() => Save(_entry)" styleClass="positive">Save</Button>
                            <Button onClick="() => Cancel(_entry)">Cancel</Button>
                        }
                        else
                        {
                            <Button onClick="() => Edit(_entry)" styleClass="bc-conf-edit">Edit</Button>
                        }
                    </div>
                }
            </div>
        }
    </div>
</div>
@if (isReadonly)
{
    <style>
        .table-section-header {
            padding-right: .25em;
        }
        .table-section > div {
            grid-template-columns: 1fr 1fr;
            height: 2em;
        }
    </style>
}
else
{
    <style>
        .table-section-header {
            padding-right: 2.75em;
        }
        .table-section > div {
            grid-template-columns: 2fr 1fr 1fr 10em;
        }
    </style>
}
<style>
    .table {
        flex: 1;
        overflow: hidden;
    }
    .table-section-content > .dirty {
        color: orange
    }
    .table-section-content > div .bc-conf-edit {
        visibility: hidden;
    }
    .table-section-content > div:hover .bc-conf-edit {
        visibility: visible;
    }
</style>

@code {

    [Parameter] public Config.BC.RemoteMachine.ServerInstance serverInstance { get; set; }

    [Parameter] public string fixedSearchText { get; set; }
    [Parameter] public bool isReadonly { get; set; }

    public class Entry
    {
        public string key;
        public string originalValue;
        public string newValue;
        public bool isDirty => originalValue != newValue;
        public string editValue;
    }
    public readonly List<Entry> entries = new();

    string searchText = string.Empty;

    IEnumerable<Entry> GetEntries()
    {
        if (!searchText.IsValidPattern(out var ignoreCase))
        {
            return [];
        }

        return entries.Where(x =>
        {
            if (x.key.SearchMatch(searchText, ignoreCase))
                return true;

            if (x.originalValue.SearchMatch(searchText, ignoreCase))
                return true;

            if (x.newValue.SearchMatch(searchText, ignoreCase))
                return true;

            return false;

        }).OrderByDescending(x => x.isDirty);
    }

    protected override Task OnInitializedAsync() => RefreshAsync();

    public Task RefreshAsync() => Run(async () =>
    {
        if (fixedSearchText is not null)
        {
            searchText = fixedSearchText;
        }

        entries.Clear();

        var navSession = await serverInstance.GetNavSessionAsync();

        if (navSession is not null)
        {
            var result = await navSession.RunScriptAsync(
                $"Get-NAVServerConfiguration -ServerInstance {serverInstance.name}"
            );

            if (!result.HasErrors)
            {
                dynamic list = result.returnValue.Single().BaseObject;

                if (list is not null)
                {
                    foreach (dynamic @object in list)
                    {
                        var value = @object.value as string;
                        entries.Add(new()
                            {
                                key = @object.key as string,
                                originalValue = value,
                                newValue = value,
                            });
                    }
                }
            }
        }
    });

    void Edit(Entry entry)
    {
        entry.editValue = entry.newValue;

        this.RenderLater();
    }

    void Save(Entry entry)
    {
        entry.newValue = entry.editValue;

        Cancel(entry);
    }

    void Cancel(Entry entry)
    {
        entry.editValue = null;

        this.RenderLater();
    }

    Task Apply() => Run(async () =>
    {
        foreach (var entry in entries)
        {
            if (entry.isDirty)
            {
                var navSession = await serverInstance.GetNavSessionAsync();

                if (navSession is not null)
                {
                    await navSession.RunScriptAsync(
                    $"Set-NAVServerConfiguration -ServerInstance {serverInstance}" +
                    $" -KeyName \"{entry.key}\" -KeyValue \"{entry.newValue}\""
                );
                }
            }
        }

        await RefreshAsync();
    });

}
